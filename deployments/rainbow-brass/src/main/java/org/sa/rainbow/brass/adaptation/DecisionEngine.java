package org.sa.rainbow.brass.adaptation;

import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import org.sa.rainbow.brass.PropertiesConnector;
import org.sa.rainbow.brass.model.map.EnvMap;
import org.sa.rainbow.brass.model.map.MapTranslator;

import com.google.common.base.Objects;





/**
 * @author jcamara
 *
 */
public class DecisionEngine {
    public static String m_export_path;
    public static MapTranslator m_mt;
    public static String m_origin;
    public static String m_destination;
    public static Map<List, String> m_candidates;
    public static Map<List, Double > m_scoreboard;
    public static double m_selected_candidate_time;
    public static PrismPolicy m_plan;
  
    public static final double INFINITY = 999999.0;

    /**
     * Initializes decision engine
     * @param props
     */
    public static void init (Properties props) throws Exception {
        if (props == null) {
            props = PropertiesConnector.DEFAULT;
        }
        m_export_path = props.getProperty (PropertiesConnector.PRISM_OUTPUT_DIR_PROPKEY);
        m_export_path = m_export_path.replaceAll ("\\\"", "");
        m_mt = new MapTranslator ();
        new PrismConnectorAPI (); // PRISM invoked via API
        m_origin="";
        m_destination="";
        m_selected_candidate_time=0.0;
        m_scoreboard= new HashMap<List, Double>();
    }

    /**
     * Sets the map to extract data 
     * @param map
     */
    public static void setMap(EnvMap map){
        m_mt.setMap(map);
    }

    /**
     * Generates all PRISM specifications corresponding to the different non-cyclic paths between
     * origin and destination locations
     * @param origin String label of origin map location
     * @param destination String label of destination map location
     */

    public static void generateCandidates (String origin, String destination){
        generateCandidates(origin, destination, false);
    }

    public static void generateCandidates(String origin, String destination, boolean inhibitTactics){
        m_origin = origin;
        m_destination = destination;
        m_candidates = m_mt.exportConstrainedTranslationsBetween(m_export_path, origin, destination, inhibitTactics);	
    }

    /**
     * Assings a score to each one of the candidate policies synthesized based on the specifications generated by
     * generateCandidates
     * 
     * @param map
     * @param batteryLevel
     *            String amount of remaining battery
     * @param robotHeading
     *            String robot Heading (needs to be converted to an String encoding an int from MissionState.Heading)
     * @throws Exception
     */
    public static void scoreCandidates (EnvMap map, String batteryLevel, String robotHeading) throws Exception {
        m_scoreboard.clear(); 
        synchronized (map){
            String m_consts = MapTranslator.INITIAL_ROBOT_LOCATION_CONST+"="+String.valueOf(map.getNodeId(m_origin)) +","+ MapTranslator.TARGET_ROBOT_LOCATION_CONST 
                    + "="+String.valueOf(map.getNodeId(m_destination))+ "," + MapTranslator.INITIAL_ROBOT_BATTERY_CONST+"="+batteryLevel+","+MapTranslator.INITIAL_ROBOT_HEADING_CONST+"="+robotHeading;

            System.out.println(m_consts);
            String result;
            for (List candidate_key : m_candidates.keySet() ){                           	
                result = PrismConnectorAPI.modelCheckFromFileS (m_candidates.get (candidate_key), m_export_path + "/mapbot.props",
                        m_candidates.get (candidate_key), 0, m_consts);
                if (!Objects.equal(result, "Infinity")) {
                    m_scoreboard.put(candidate_key, Double.valueOf(result));
                }
                else {
                    m_scoreboard.put(candidate_key, INFINITY);
                }
            }
        }
    }

    /**
     * Selects the policy with the best score
     * @return String filename of the selected policy
     */
    public static String selectPolicy(){
        Map.Entry<List, Double> maxEntry = m_scoreboard.entrySet().iterator().next();
        for (Map.Entry<List, Double> entry : m_scoreboard.entrySet())
        {
            if (entry.getValue().compareTo(maxEntry.getValue()) < 0)
            {
                maxEntry = entry;
            }
        }
        m_selected_candidate_time = maxEntry.getValue();
        System.out.println("Selected candidate policy: "+m_candidates.get(maxEntry.getKey()));
        return m_candidates.get(maxEntry.getKey())+".adv";
    }

    public static double getSelectedPolicyTime(){
        return m_selected_candidate_time;
    }

    /**
     * Class test
     * @param args
     */
    public static void main (String[] args) throws Exception {
        init (null);

        List<Point2D> coordinates = new ArrayList<Point2D>();
        PrismPolicy pp=null;

        EnvMap dummyMap = new EnvMap (null, null);
        setMap(dummyMap);
        for (int i=15000; i< 15500; i+=500){
            generateCandidates("l5", "l1");
            scoreCandidates(dummyMap, String.valueOf(i), "1");
            System.out.println(String.valueOf(m_scoreboard));	        
            pp = new PrismPolicy(selectPolicy());
            pp.readPolicy();  
            String plan = pp.getPlan().toString();
            System.out.println(plan);
            PolicyToIG translator = new PolicyToIG(pp, dummyMap);
            System.out.println (translator.translate (20394, false));
            coordinates.add(new Point2D.Double(i, m_selected_candidate_time));
        }

        for (int j=0; j< coordinates.size(); j++){
            System.out.println(" ("+String.valueOf(coordinates.get(j).getX())+", "+String.valueOf(coordinates.get(j).getY())+") ");
        }

//        MapTranslator.exportConstrainedToPlanMapTranslation("/Users/jcamara/Dropbox/Documents/Work/Projects/BRASS/rainbow-prototype/trunk/rainbow-brass/prismtmp/prismtmp.prism", pp.getPlan());

    }

}
